<html xmlns:tal="http://xml.zope.org/namespaces/tal"
      xmlns:metal="http://xml.zope.org/namespaces/metal"
      metal:use-macro="here/main_template/macros/master">

<body>

<div metal:fill-slot="main">
  <link rel="Stylesheet" type="text/css" href="doxygen.css" />
<!-- Generated by Doxygen 1.5.9 -->
  <div class="navpath"><a class="el" href="namespaceBALL.html">BALL</a>::<a class="el" href="namespaceBALL_1_1RTTI.html">RTTI</a>
  </div>
<div class="contents">
<h1>BALL::RTTI Namespace Reference<br/>
<small>
[<a class="el" href="group__Common.html">Common Definitions</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br/><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceBALL_1_1RTTI.html#aa57a5f0cce951b47a8846b167c07bb19">getDefault</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceBALL_1_1RTTI.html#afa8f6eb4a3c02de16941e9522778103a">getNew</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceBALL_1_1RTTI.html#a567f0ff8782b1d31f24080140fe497ba">getName</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceBALL_1_1RTTI.html#a84645824f11a38f314c5ec1e3b87c6da">getClassID</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceBALL_1_1RTTI.html#a14ffe2f54b12aaace0a297ecc89ee3d7">getStreamName</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceBALL_1_1RTTI.html#aac5db6c1ad173cbbb38ba58ccd015f55">isKindOf</a> (const U &amp;u)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceBALL_1_1RTTI.html#a36476c3a353c8e9da0b12e8d12608d81">castTo</a> (const U &amp;u)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceBALL_1_1RTTI.html#a0cb9f3b2fdbe3c782369509b14a111cd">isInstanceOf</a> (const U &amp;u)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Simplified RunTime Type Identification. ANSI C++ provides support for runtime type identification (<a class="el" href="namespaceBALL_1_1RTTI.html">RTTI</a>). However, the support is very basic. The template functions of the <a class="el" href="namespaceBALL_1_1RTTI.html">RTTI</a> namespace provide a more readable support for <a class="el" href="namespaceBALL_1_1RTTI.html">RTTI</a>. It defines predicates such as <a class="el" href="namespaceBALL_1_1RTTI.html#aac5db6c1ad173cbbb38ba58ccd015f55">isKindOf </a> that simplify tests on the hereditary relationship of different objects. </p>
<dl class="user"><dt><b></b></dt><dd>To use the <a class="el" href="namespaceBALL_1_1RTTI.html">RTTI</a> template functions, parametrize it with the type you are interested in. For example, to find out whether a given molecule is a protein, the following code can be used: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">        Molecule&amp; m =...;
        ...
        <span class="keywordflow">if</span> (RTTI::isKindOf&lt;Protein&gt;(m)) 
        {
          <span class="comment">// perform some protein specific operations</span>
        } <span class="keywordflow">else</span> {
          <span class="comment">// this is only a molecule...</span>
        }
</pre></div> </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a36476c3a353c8e9da0b12e8d12608d81"></a><!-- doxytag: member="BALL::RTTI::castTo" ref="a36476c3a353c8e9da0b12e8d12608d81" args="(const U &amp;u)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* BALL::RTTI::castTo </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cast an object to a specialized class. <b>Example:</b> </p>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">          Composite* composite = ...;
          ...
        
          <span class="comment">// check whether the composite is also an atom</span>
          <span class="keywordflow">if</span> (RTTI::isKindOf&lt;Atom&gt;(composite))
          {
            <span class="comment">// perform some atom specific actions</span>
            <a class="code" href="namespaceBALL_1_1PDB.html#a0b90efd02f78a2adb8d2ef346ac30462">Atom</a>* atom = RTTI::castTo&lt;Atom&gt;(*composite);
            ...
            atom-&gt;setCharge(0);
            ...
          }
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="a84645824f11a38f314c5ec1e3b87c6da"></a><!-- doxytag: member="BALL::RTTI::getClassID" ref="a84645824f11a38f314c5ec1e3b87c6da" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* BALL::RTTI::getClassID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a void pointer that is unique for each class. </p>

</div>
</div>
<a class="anchor" id="aa57a5f0cce951b47a8846b167c07bb19"></a><!-- doxytag: member="BALL::RTTI::getDefault" ref="aa57a5f0cce951b47a8846b167c07bb19" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; BALL::RTTI::getDefault </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to a static default instance of the corresponding class. This method is basically intended to provide a default object for certain operations that require an instance of a certain class without really using this instance. It is mainly used inside the <a class="el" href="namespaceBALL_1_1RTTI.html">RTTI</a> class. </p>

</div>
</div>
<a class="anchor" id="a567f0ff8782b1d31f24080140fe497ba"></a><!-- doxytag: member="BALL::RTTI::getName" ref="a567f0ff8782b1d31f24080140fe497ba" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char* BALL::RTTI::getName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the name of the class. This method returns the name of the class as given by <code>typeid(&lt;class instance&gt;.name())</code>. No additional name demangling and whitespace substitution are performed. </p>

</div>
</div>
<a class="anchor" id="afa8f6eb4a3c02de16941e9522778103a"></a><!-- doxytag: member="BALL::RTTI::getNew" ref="afa8f6eb4a3c02de16941e9522778103a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* BALL::RTTI::getNew </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a void pointer to a new instance of the class. Use this method to provide an easy factory for objects of a certain class. The main use of this function lies in object persistence. The <a class="el" href="classBALL_1_1PersistenceManager.html">PersistenceManager </a> needs a function for the dynamic creation of objects. </p>

</div>
</div>
<a class="anchor" id="a14ffe2f54b12aaace0a297ecc89ee3d7"></a><!-- doxytag: member="BALL::RTTI::getStreamName" ref="a14ffe2f54b12aaace0a297ecc89ee3d7" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char* BALL::RTTI::getStreamName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the demangled class name. The class name is demangled (as far as possible) and in the resulting string blanks are substituted by underscores, so the name can be read from a stream as one string. The typical usage is something like </p>
<div class="fragment"><pre class="fragment">          String class_name = RTTI::getStreamName&lt;Residue&gt;();
          ...
</pre></div> 
<p>References <a class="el" href="group__Common.html#ga25b56391c773bad0946e5ddf7211f59d">BALL::streamClassName()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cb9f3b2fdbe3c782369509b14a111cd"></a><!-- doxytag: member="BALL::RTTI::isInstanceOf" ref="a0cb9f3b2fdbe3c782369509b14a111cd" args="(const U &amp;u)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> BALL::RTTI::isInstanceOf </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <b>true</b> if a given object is an instance of a given class. If <code>u</code> is an instance of <code>T</code>, this predicate returns <b>true</b>. If <code>u</code> is an instance of a class that is derived from <code>T</code> or a base class of <code>T</code>, it returns false. </p>

</div>
</div>
<a class="anchor" id="aac5db6c1ad173cbbb38ba58ccd015f55"></a><!-- doxytag: member="BALL::RTTI::isKindOf" ref="aac5db6c1ad173cbbb38ba58ccd015f55" args="(const U &amp;u)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> BALL::RTTI::isKindOf </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if <code>u</code> is a kind of T. If <code>u</code> is an instance of a class derived from T, this predicate returns true: </p>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">          Protein p;

          <span class="comment">// return true, since Protein is derived from Molecule</span>
          <span class="keywordtype">bool</span> is_molecule = RTTI::isKindOf&lt;Molecule&gt;(p);
</pre></div> </dd></dl>

</div>
</div>
</div>
</div>
</body>
</html>
