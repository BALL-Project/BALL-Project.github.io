<html xmlns:tal="http://xml.zope.org/namespaces/tal"
      xmlns:metal="http://xml.zope.org/namespaces/metal"
      metal:use-macro="here/main_template/macros/master">

<body>

<div metal:fill-slot="main">
  <link rel="Stylesheet" type="text/css" href="doxygen.css" />
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1>Common Definitions<br/>
<small>
[<a class="el" href="group__Foundation.html">Foundation Classes</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br/><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBALL_1_1Exception_1_1GeneralException.html">BALL::Exception::GeneralException</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBALL_1_1HashFunction.html">BALL::HashFunction&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBALL_1_1Limits.html">BALL::Limits&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBALL_1_1VersionInfo.html">BALL::VersionInfo</a></td></tr>
<tr><td colspan="2"><br/><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBALL_1_1Constants.html">BALL::Constants</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBALL_1_1Exception.html">BALL::Exception</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBALL_1_1RTTI.html">BALL::RTTI</a></td></tr>
<tr><td colspan="2"><br/><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BALL_EXPORT std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Common.html#ga73107a753d5464bcefe785ab0419ba7e">BALL::operator&lt;&lt;</a> (std::ostream &amp;os, const Exception::GeneralException &amp;e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BALL_EXPORT string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Common.html#ga25b56391c773bad0946e5ddf7211f59d">BALL::streamClassName</a> (const std::type_info &amp;t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Common.html#ga7531fd77ac8e175306413c4539a10c01">BALL_CREATE_DEEP</a>(name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Common.html#ga84998f74fd7a58cecfcbb81d48b4323b">BALL_CREATE</a>(name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Common.html#ga502ef000f76f14d74454b2961a44160a">BALL_DEFINE_CREATE</a>(name)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This chapter contains all relevant information on very fundamental definitions and classes used throughout <a class="el" href="namespaceBALL.html">BALL</a> (part of the <b> Foundation Classes</b>). </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga84998f74fd7a58cecfcbb81d48b4323b"></a><!-- doxytag: member="create.h::BALL_CREATE" ref="ga84998f74fd7a58cecfcbb81d48b4323b" args="(name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BALL_CREATE</td>
          <td>(</td>
          <td class="paramtype">name&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
  <span class="keyword">virtual</span> <span class="keywordtype">void</span>* create(<span class="keywordtype">bool</span> <span class="comment">/* deep */</span> = <span class="keyword">true</span>, <span class="keywordtype">bool</span> empty = <span class="keyword">false</span>) const\
  {\
    <span class="keywordtype">void</span>* ptr;\
    <span class="keywordflow">if</span> (empty == <span class="keyword">true</span>)\
    {\
      ptr = (<span class="keywordtype">void</span>*)<span class="keyword">new</span> name;\
    }\
    <span class="keywordflow">else</span>\
    {\
      ptr = (<span class="keywordtype">void</span>*)<span class="keyword">new</span> name(*<span class="keyword">this</span>);\
    }\
    \
    <span class="keywordflow">return</span> ptr;\
  }\
  \
  <span class="keyword">static</span> <span class="keywordtype">void</span>* createDefault()\
  {\
    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(<span class="keyword">new</span> name);\
  }
</pre></div><p>Virtual construction macro. This macro is used to define the virtual <b>create</b> method for classes that do not define a copy constructor taking a second argument (boolean, deep or shallow copy). On inclusion of this macro in the public interface of a class, the virtual creation method becomes available. The create method's signature is as follows: <code>virtual void* <b>create</b>(bool deep = true, bool empty = false) const</code> </p>
<dl class="user"><dt><b></b></dt><dd>The create method either creates an empty default object of the class (<code>empty == <b>true</b></code>) or a copy of the object. The use of the create method requires a (public) default constructor (when creating an empty copy) and a copy constructor taking a reference to an object. The macro also implements a static method <code>createDefault</code> that returns a void pointer to a new instance of <code>name</code>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the class name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7531fd77ac8e175306413c4539a10c01"></a><!-- doxytag: member="create.h::BALL_CREATE_DEEP" ref="ga7531fd77ac8e175306413c4539a10c01" args="(name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BALL_CREATE_DEEP</td>
          <td>(</td>
          <td class="paramtype">name&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
  <span class="keyword">virtual</span> <span class="keywordtype">void</span>* create(<span class="keywordtype">bool</span> deep = <span class="keyword">true</span>, <span class="keywordtype">bool</span> empty = <span class="keyword">false</span>) const\
  {\
    <span class="keywordtype">void</span>* ptr;\
    <span class="keywordflow">if</span> (empty == <span class="keyword">true</span>)\
    {\
      ptr = (<span class="keywordtype">void</span>*)<span class="keyword">new</span> name;\
    }\
    <span class="keywordflow">else</span>\
    {\
      ptr = (<span class="keywordtype">void</span>*)<span class="keyword">new</span> name(*<span class="keyword">this</span>, deep);\
    }\
    \
    <span class="keywordflow">return</span> ptr;\
  }\
  \
  <span class="keyword">static</span> <span class="keywordtype">void</span>* createDefault()\
  {\
    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(<span class="keyword">new</span> name);\
  }
</pre></div><p>Virtual construction macro. This macro is used to define the virtual <b>create</b> method. On inclusion of this macro in the public interface of a class, the virtual creation method becomes available. The create method's signature is as follows: <code>virtual void* <b>create</b>(bool deep = true, bool empty = false) const</code> </p>
<dl class="user"><dt><b></b></dt><dd>The create method either creates an empty default object of the class (<code>empty == <b>true</b></code>) or a copy of the object. The copy is either deep (<code>deep == <b>true</b></code>) or shallow (<code>deep == <b>false</b></code>). By default, the create methods returns a pointer to a deep copy of the object. The use of the create method requires a (public) default constructor (when creating an empty copy) or a copy constructor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The macro also implements a static method <code>createDefault</code> that returns a void pointer to a new instance of <code>name</code>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the class name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga502ef000f76f14d74454b2961a44160a"></a><!-- doxytag: member="create.h::BALL_DEFINE_CREATE" ref="ga502ef000f76f14d74454b2961a44160a" args="(name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BALL_DEFINE_CREATE</td>
          <td>(</td>
          <td class="paramtype">name&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">\
  <span class="keyword">virtual</span> <span class="keywordtype">void</span>* create(<span class="keywordtype">bool</span> deep = <span class="keyword">true</span>, <span class="keywordtype">bool</span> empty = <span class="keyword">false</span>) <span class="keyword">const</span>;\
  <span class="keyword">static</span> <span class="keywordtype">void</span>* createDefault();
</pre></div><p>Virtual cloning method definition macro. If the create method has to be implemented by the user, this macro just defines the create method and the createDefault method. The function signatures are: </p>
<div class="fragment"><pre class="fragment">
			virtual void* create(bool deep = true, bool empty = false) const;
			static void* createDefault();
		</pre></div> 
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga73107a753d5464bcefe785ab0419ba7e"></a><!-- doxytag: member="BALL::operator&lt;&lt;" ref="ga73107a753d5464bcefe785ab0419ba7e" args="(std::ostream &amp;os, const Exception::GeneralException &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BALL_EXPORT std::ostream&amp; BALL::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Exception::GeneralException &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output operator for exceptions. All <a class="el" href="namespaceBALL.html">BALL</a> exceptions can be printed to an arbitrary output stream. Information written contains the exception class, the error message, and the location (file, line number). The following code block can thus be used to catch any <a class="el" href="namespaceBALL.html">BALL</a> exceptions and convert them to human readable information: </p>
<div class="fragment"><pre class="fragment">
				try
				{
					.... // some code which potentially throws an exception
				}
				catch (Exception::GeneralException&amp; e)
				{
					Log.error() &lt;&lt; "caught exception: " &lt;&lt; e &lt;&lt; std::endl;
				}
				</pre></div> 
</div>
</div>
<a class="anchor" id="ga25b56391c773bad0946e5ddf7211f59d"></a><!-- doxytag: member="BALL::streamClassName" ref="ga25b56391c773bad0946e5ddf7211f59d" args="(const std::type_info &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BALL_EXPORT string BALL::streamClassName </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a unique name for a class. This name contains no blanks. It is usually derived by substituting all blanks in the name (as returned by <a class="el" href="namespaceBALL_1_1RTTI.html#a567f0ff8782b1d31f24080140fe497ba">RTTI::getName()</a>) with underscores ("_"). In the case of <code>gcc</code>, however a name demangling decodes the string first. This function is needed for object persistence. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>the <code>type_info</code> structure as returned by <code>typeid</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>string the coverted class name </dd></dl>

<p>Referenced by <a class="el" href="rtti_8h_source.html#l00124">BALL::RTTI::getStreamName()</a>.</p>

</div>
</div>
</div>
</div>
</body>
</html>
