<html xmlns:tal="http://xml.zope.org/namespaces/tal"
      xmlns:metal="http://xml.zope.org/namespaces/metal"
      metal:use-macro="here/main_template/macros/master">

<body>

<div metal:fill-slot="main">
  <link rel="Stylesheet" type="text/css" href="doxygen.css" />
<!-- Generated by Doxygen 1.5.9 -->
  <div class="navpath"><a class="el" href="namespaceBALL.html">BALL</a>::<a class="el" href="classBALL_1_1AtomBijection.html">AtomBijection</a>
  </div>
<div class="contents">
<h1>BALL::AtomBijection Class Reference<br/>
<small>
[<a class="el" href="group__StructureMapping.html">Mapping of molecular structures</a>]</small>
</h1><!-- doxytag: class="BALL::AtomBijection" --><!-- doxytag: inherits="std::vector" -->
<p><code>#include &lt;<a class="el" href="atomBijection_8h_source.html">BALL/STRUCTURE/atomBijection.h</a>&gt;</code></p>

<p>Inherits std::vector&lt;std::pair&lt;Atom*, Atom*&gt; &gt;.</p>

<p><a href="classBALL_1_1AtomBijection-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br/><h2>Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Type definitions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="classBALL_1_1Atom.html">Atom</a> *, <a class="el" href="classBALL_1_1Atom.html">Atom</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBALL_1_1AtomBijection.html#a496e01dbe395aa7de208b5568059545d">AtomPair</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::pair<br class="typebreak"/>
&lt; <a class="el" href="classBALL_1_1Atom.html">Atom</a> *, <a class="el" href="classBALL_1_1Atom.html">Atom</a> * &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBALL_1_1AtomBijection.html#a75d1fc43262673b67c5165074bffe1e0">PairVector</a></td></tr>
<tr><td colspan="2"><br/><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBALL_1_1AtomBijection.html#a4080e8b369e430eb2acf3862d735b80a">AtomBijection</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBALL_1_1AtomBijection.html#a5dda217656035389701d50ede64fb5a6">AtomBijection</a> (<a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;A, <a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;B)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBALL_1_1AtomBijection.html#aa85d5dbcedb2129e5617d7a2d654f559">~AtomBijection</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Destructor. </p>
 <a href="#aa85d5dbcedb2129e5617d7a2d654f559"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Bijection construction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBALL__SIZE__TYPE.html">Size</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBALL_1_1AtomBijection.html#a04a73d59f9d85ec8dc11afd24829e43a">assignTrivial</a> (<a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;A, <a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;B)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBALL__SIZE__TYPE.html">Size</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBALL_1_1AtomBijection.html#a4d4ff6d715bfb866afbe43e458649ab3">assignByName</a> (<a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;A, <a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;B)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBALL__SIZE__TYPE.html">Size</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBALL_1_1AtomBijection.html#a670d6f51a0f6d6fe50c7f564ea8f5c63">assignCAlphaAtoms</a> (<a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;A, <a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;B)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBALL__SIZE__TYPE.html">Size</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBALL_1_1AtomBijection.html#a3ad26ce6c79226c608c0c5161f7abbc9">assignBackboneAtoms</a> (<a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;A, <a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;B)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBALL_1_1AtomBijection.html#a54162ab434c4a10942d8bdabfc49fded">calculateRMSD</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Calculate the root mean squared deviation of the mapped atoms. </p>
 <a href="#a54162ab434c4a10942d8bdabfc49fded"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classBALL_1_1Atom.html">Atom</a> bijection. This class implements a mapping of two sets of atoms onto each other. It is used by the <a class="el" href="classBALL_1_1StructureMapper.html">StructurMapper </a> class and the <a class="el" href="classBALL_1_1RMSDMinimizer.html">RMSDMinimizer </a> classes to define which atoms are mapped onto each other. <code>There</code> are a few methods for general mappings (based on atom order, atom names, etc.) that should suffice for most applications. If you want to match proteins based on particular mappings (e.g. based on a pairwise alignment), you should create the mapping yourself. This is easily done by pushing an AtomPair into the vector: </p>
<div class="fragment"><pre class="fragment">        <a class="code" href="namespaceBALL_1_1PDB.html#a0b90efd02f78a2adb8d2ef346ac30462">Atom</a>* atom1 = ...;
        <a class="code" href="namespaceBALL_1_1PDB.html#a0b90efd02f78a2adb8d2ef346ac30462">Atom</a>* atom2 = ...;
  
        <span class="comment">// Create an empty bijection</span>
        <a class="code" href="classBALL_1_1AtomBijection.html#a4080e8b369e430eb2acf3862d735b80a">AtomBijection</a> bijection;

        <span class="comment">// Map atom1 onto atom2.</span>
        bijection.push_back(<a class="code" href="classBALL_1_1AtomBijection.html#a496e01dbe395aa7de208b5568059545d">AtomBijection::AtomPair</a>(atom1, atom2));
</pre></div><p> <code>The</code> class behaves more or less like the vector of atom pointer pairs it truly is. In particular, the STL container interface has been fully implemented. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a496e01dbe395aa7de208b5568059545d"></a><!-- doxytag: member="BALL::AtomBijection::AtomPair" ref="a496e01dbe395aa7de208b5568059545d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classBALL_1_1Atom.html">Atom</a>*, <a class="el" href="classBALL_1_1Atom.html">Atom</a>*&gt; <a class="el" href="classBALL_1_1AtomBijection.html#a496e01dbe395aa7de208b5568059545d">BALL::AtomBijection::AtomPair</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A struct for representing an atom pair of the mapping. </p>

</div>
</div>
<a class="anchor" id="a75d1fc43262673b67c5165074bffe1e0"></a><!-- doxytag: member="BALL::AtomBijection::PairVector" ref="a75d1fc43262673b67c5165074bffe1e0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;std::pair&lt;<a class="el" href="classBALL_1_1Atom.html">Atom</a>*, <a class="el" href="classBALL_1_1Atom.html">Atom</a>*&gt; &gt; <a class="el" href="classBALL_1_1AtomBijection.html#a75d1fc43262673b67c5165074bffe1e0">BALL::AtomBijection::PairVector</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4080e8b369e430eb2acf3862d735b80a"></a><!-- doxytag: member="BALL::AtomBijection::AtomBijection" ref="a4080e8b369e430eb2acf3862d735b80a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BALL::AtomBijection::AtomBijection </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default constructor </p>

</div>
</div>
<a class="anchor" id="a5dda217656035389701d50ede64fb5a6"></a><!-- doxytag: member="BALL::AtomBijection::AtomBijection" ref="a5dda217656035389701d50ede64fb5a6" args="(AtomContainer &amp;A, AtomContainer &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BALL::AtomBijection::AtomBijection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a trivial bijection between to atom containers. Construct a simple bijection mapping the atoms of the two atom containers onto each other. The mapping iterates over the atoms and stops assigning pairs of atoms as soon as the smalles of the two atom sets is fully assigned. The larger of the two atom container can thus contain unassigned atoms. No checking with respect to atom names, elements or the like are being made. <code></code> </p>
<p>This corresponds to calling assignTrivial after default construction </p>

</div>
</div>
<a class="anchor" id="aa85d5dbcedb2129e5617d7a2d654f559"></a><!-- doxytag: member="BALL::AtomBijection::~AtomBijection" ref="aa85d5dbcedb2129e5617d7a2d654f559" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual BALL::AtomBijection::~AtomBijection </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3ad26ce6c79226c608c0c5161f7abbc9"></a><!-- doxytag: member="BALL::AtomBijection::assignBackboneAtoms" ref="a3ad26ce6c79226c608c0c5161f7abbc9" args="(AtomContainer &amp;A, AtomContainer &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBALL__SIZE__TYPE.html">Size</a> BALL::AtomBijection::assignBackboneAtoms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign the backbone atoms ordered by sequence. This method iterated over all residues and assigns the backbone atoms (i.e. all atoms named "CA", "C", "N", "H", and "O" in every residue with the property AMINO_ACID) of the two proteins in the order they are traversed. The mapping terminates, if the traversal of the residues in one of the two atom containers terminates. <code></code>  The number of atom pairs mapped </p>

</div>
</div>
<a class="anchor" id="a4d4ff6d715bfb866afbe43e458649ab3"></a><!-- doxytag: member="BALL::AtomBijection::assignByName" ref="a4d4ff6d715bfb866afbe43e458649ab3" args="(AtomContainer &amp;A, AtomContainer &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBALL__SIZE__TYPE.html">Size</a> BALL::AtomBijection::assignByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign the atom pairs through a name matching. This method creates a mapping based on the atom names. If the atom is contained in a Residue/Protein, the name consists of the fully qualified name (&lt;chain&gt;:&lt;residue name&gt;=""&gt;:&lt;residue id&gt;=""&gt;:&lt;atom name&gt;=""&gt;). If no pair of atoms could by matched this way, it will try to match by atom names only (not considering residues, chains or the like). <code>The</code> method constructs a hash map for all atom names, so run time is linear in the number of atoms. <code>The</code> number of atoms mapped is returned. </p>

</div>
</div>
<a class="anchor" id="a670d6f51a0f6d6fe50c7f564ea8f5c63"></a><!-- doxytag: member="BALL::AtomBijection::assignCAlphaAtoms" ref="a670d6f51a0f6d6fe50c7f564ea8f5c63" args="(AtomContainer &amp;A, AtomContainer &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBALL__SIZE__TYPE.html">Size</a> BALL::AtomBijection::assignCAlphaAtoms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign the C-alpha atoms ordered by sequence. This method iterated over all residues and assigns the C-alpha atoms (i.e. all atoms named "CA" in a residue with the property AMINO_ACID) of the two proteins in the order they are traversed. The size of the mapping corresponds to the minimum of the number of C-alpha atoms of both atom containers. <code></code>  The number of atom pairs mapped </p>

</div>
</div>
<a class="anchor" id="a04a73d59f9d85ec8dc11afd24829e43a"></a><!-- doxytag: member="BALL::AtomBijection::assignTrivial" ref="a04a73d59f9d85ec8dc11afd24829e43a" args="(AtomContainer &amp;A, AtomContainer &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBALL__SIZE__TYPE.html">Size</a> BALL::AtomBijection::assignTrivial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBALL_1_1AtomContainer.html">AtomContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign all atoms in the two atom containers in order. Construct a simple bijection mapping the atoms of the two atom containers onto each other. The mapping iterates over the atoms and stops assigning pairs of atoms as soon as the smalles of the two atom sets is fully assigned. The larger of the two atom container can thus contain unassigned atoms. No checking with respect to atom names, elements or the like are being made. <code>This</code> trivial bijection is useful, if the two atom containers correspond to exactly the same structure (i.e. they just differ in their conformations). Care must be taken that the order of atoms is correct. Beware of adding hydrogens, which might mess up atom order in some cases. <code>The</code> number of atoms mapped is returned. </p>

</div>
</div>
<a class="anchor" id="a54162ab434c4a10942d8bdabfc49fded"></a><!-- doxytag: member="BALL::AtomBijection::calculateRMSD" ref="a54162ab434c4a10942d8bdabfc49fded" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> BALL::AtomBijection::calculateRMSD </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the root mean squared deviation of the mapped atoms. </p>

</div>
</div>
</div>
</div>
</body>
</html>
