<html xmlns:tal="http://xml.zope.org/namespaces/tal"
      xmlns:metal="http://xml.zope.org/namespaces/metal"
      metal:use-macro="here/main_template/macros/master">

<body>

<div metal:fill-slot="main">
  <link rel="Stylesheet" type="text/css" href="doxygen.css" />
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1>Class Black Box Testing<br/>
<small>
[<a class="el" href="group__Concepts.html">Concepts</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br/><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#ga90ef7ac5849c83a72a0f1425f28939f2">PRECISION</a>(a)&nbsp;&nbsp;&nbsp;TEST::precision = (a);</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#ga7a40a89e644997d4c2ff42b1068658e2">START_TEST</a>(class_name, version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#gaefcd1ca1799d2395f7bbe3c50bcc8ff8">END_TEST</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#ga3f863350d1b8ff0e07f55d6668b868ff">CHECK</a>(test_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#ga2491d6c44db439274567cea0a3e6f712">STATUS</a>(message)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#ga62c939ffea0f34a0211837f4dbecee0a">RESULT</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#gadf364cea1469a3b7ebfde9e01332265f">NEW_TMP_FILE</a>(filename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#ga206d7219a2ba5116b25b61457a629e62">TEST_REAL_EQUAL</a>(a, b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#ga28c3e33e75987220375e36d1480e26ec">TEST_EQUAL</a>(a, b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#gaf2f6f2b204d65f32c50a4411dc590fa3">TEST_NOT_EQUAL</a>(a, b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#ga29e985393ac63f000023bf684f4d03fc">TEST_EXCEPTION</a>(exception_type, command)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#ga6fff47799e22d307f16eabdfbb0291e2">TEST_PRECONDITION_EXCEPTION</a>(command)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#ga6dfb51fad5e70a1e970bc965094704e0">ABORT_IF</a>(condition)&nbsp;&nbsp;&nbsp;if (condition) break;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#ga219dba5ec44005d226e707f1ab8edd2e">TEST_FILE</a>(filename, templatename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#ga6dd175ba0b13a37ca85a7493dca42f05">TEST_FILE_REGEXP</a>(filename, templatename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#gabafab2d986f098b4b890139def1a44e9">CAPTURE_OUTPUT_LEVEL</a>(level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#gad337f390e82b1d72d3e4845f6cb52803">CAPTURE_OUTPUT_LEVEL_RANGE</a>(minlevel, maxlevel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClassTest.html#gac3823150353426a957bb759359c3ceee">COMPARE_OUTPUT</a>(text)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>To provide a maximum reliability for all <a class="el" href="namespaceBALL.html">BALL</a> classes, each class provides its own test program to ensure that each class compiles and behaves (at least basically) as intended.</p>
<p>The testprograms reside in the directory source/TEST, they may be built and executed by calling <b>make test</b>.</p>
<p>Each test program prints after execution either "PASSED" or "FAILED". If any of the subtest contained in the test program fails, the whole test failed. The result of the test program can also be checked via its exit code. An exit code of zero means "PASSED", non-zero exit code means "FAILED".</p>
<p>There are several macros defined to simplify the creation of a test program and to provide a common interface. Each test program consists of several subtests which usually test one method or property of the class. Each of this subtests uses a series of elementary tests to check the functionality of the method.</p>
<p>A number of elementary tests has been implemented that is sufficient for most cases:</p>
<ul>
<li><a class="el" href="group__ClassTest.html#ga28c3e33e75987220375e36d1480e26ec">TEST_EQUAL </a></li>
<li><a class="el" href="group__ClassTest.html#gaf2f6f2b204d65f32c50a4411dc590fa3">TEST_NOT_EQUAL </a></li>
<li><a class="el" href="group__ClassTest.html#ga206d7219a2ba5116b25b61457a629e62">TEST_REAL_EQUAL </a> A subtest is defined by calling the <a class="el" href="group__ClassTest.html#ga3f863350d1b8ff0e07f55d6668b868ff">CHECK </a> macro with the subtest name as an argument. Then a series of calls to <b>TEST</b> macros follows, mixed with standard <a class="el" href="namespaceBALL.html">BALL</a> code (remember to include all neccessary header files). The subtest is terminated by calling <a class="el" href="group__ClassTest.html#ga62c939ffea0f34a0211837f4dbecee0a">RESULT </a> . Use the two macros <a class="el" href="group__ClassTest.html#ga7a40a89e644997d4c2ff42b1068658e2">START_TEST </a> and <a class="el" href="group__ClassTest.html#gaefcd1ca1799d2395f7bbe3c50bcc8ff8">END_TEST </a> to generate a complete test program.</li>
</ul>
<p>To create a new test program, use the file <a href="../../source/BALL/TEST/Skeleton_test.C">source/TEST/Skeleton_test.C</a> </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga6dfb51fad5e70a1e970bc965094704e0"></a><!-- doxytag: member="classTest.h::ABORT_IF" ref="ga6dfb51fad5e70a1e970bc965094704e0" args="(condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ABORT_IF</td>
          <td>(</td>
          <td class="paramtype">condition&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;if (condition) break;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Skip remainder of subtest. If the condition is not fulfilled, the remainder of the test is skipped. The status (whether it fails or passes) remains unchanged. </p>

</div>
</div>
<a class="anchor" id="gabafab2d986f098b4b890139def1a44e9"></a><!-- doxytag: member="classTest.h::CAPTURE_OUTPUT_LEVEL" ref="gabafab2d986f098b4b890139def1a44e9" args="(level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAPTURE_OUTPUT_LEVEL</td>
          <td>(</td>
          <td class="paramtype">level&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{\
    std::ostrstream TEST_strstr;\
    <a class="code" href="namespaceBALL.html#a3285ecab87c03c25e43e326d3cf3e79e">Log</a>.remove(std::cout);\
    <a class="code" href="namespaceBALL.html#a3285ecab87c03c25e43e326d3cf3e79e">Log</a>.remove(std::cerr);\
    <a class="code" href="namespaceBALL.html#a3285ecab87c03c25e43e326d3cf3e79e">Log</a>.insert(TEST_strstr, level, level);
</pre></div><p>Redirect output to the global logging facility. This macro (together with <a class="el" href="group__ClassTest.html#gac3823150353426a957bb759359c3ceee">COMPARE_OUTPUT </a> ) can be used to ensure that a function prints an error message to the global logging facility <a class="el" href="classBALL_1_1LogStream.html">Log </a> . It disables the output to <code>cout</code> and <code>cerr</code> and redirects all output to <code>level</code> to a temporary <code>ostringstream</code>. The contents of this stream can be compared with the expected output afterwards using the macro <a class="el" href="group__ClassTest.html#gac3823150353426a957bb759359c3ceee">COMPARE_OUTPUT </a> . Each <code>CAPTURE_OUTPUT</code> requires exactly one subsequent <a class="el" href="group__ClassTest.html#gac3823150353426a957bb759359c3ceee">COMPARE_OUTPUT </a> macro. </p>

</div>
</div>
<a class="anchor" id="gad337f390e82b1d72d3e4845f6cb52803"></a><!-- doxytag: member="classTest.h::CAPTURE_OUTPUT_LEVEL_RANGE" ref="gad337f390e82b1d72d3e4845f6cb52803" args="(minlevel, maxlevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAPTURE_OUTPUT_LEVEL_RANGE</td>
          <td>(</td>
          <td class="paramtype">minlevel, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">maxlevel&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{\
    std::ostrstream TEST_strstr;\
    <a class="code" href="namespaceBALL.html#a3285ecab87c03c25e43e326d3cf3e79e">Log</a>.remove(std::cout);\
    <a class="code" href="namespaceBALL.html#a3285ecab87c03c25e43e326d3cf3e79e">Log</a>.remove(std::cerr);\
    <a class="code" href="namespaceBALL.html#a3285ecab87c03c25e43e326d3cf3e79e">Log</a>.insert(TEST_strstr, minlevel, maxlevel);
</pre></div><p>Redirect output to the global logging facility. This macro (together with <a class="el" href="group__ClassTest.html#gac3823150353426a957bb759359c3ceee">COMPARE_OUTPUT </a> ) can be used to ensure that a function prints an error message to the global logging facility <a class="el" href="classBALL_1_1LogStream.html">Log </a> . It disables the output to <code>cout</code> and <code>cerr</code> and redirects all output to <code>level</code> to a temporary <code>ostringstream</code>. The contents of this stream can be compared with the expected output afterwards using the macro <a class="el" href="group__ClassTest.html#gac3823150353426a957bb759359c3ceee">COMPARE_OUTPUT </a> . Each <code>CAPTURE_OUTPUT</code> requires exactly one subsequent <a class="el" href="group__ClassTest.html#gac3823150353426a957bb759359c3ceee">COMPARE_OUTPUT </a> macro. </p>

</div>
</div>
<a class="anchor" id="ga3f863350d1b8ff0e07f55d6668b868ff"></a><!-- doxytag: member="classTest.h::CHECK" ref="ga3f863350d1b8ff0e07f55d6668b868ff" args="(test_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK</td>
          <td>(</td>
          <td class="paramtype">test_name&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">TEST::test = <span class="keyword">true</span>;\
  TEST::newline = <span class="keyword">false</span>;\
  <span class="keywordflow">if</span> (TEST::verbose &gt; 0)\
    std::cout &lt;&lt; <span class="stringliteral">&quot;checking &quot;</span> &lt;&lt; #test_name &lt;&lt; <span class="stringliteral">&quot;... &quot;</span> &lt;&lt; std::flush;\
  <span class="keywordflow">try</span>\
  {\
    <span class="keywordflow">while</span> (<span class="keyword">true</span>)\
    {\
</pre></div><p>Declare subtest name. This macro is used to declare the name of a subtest. If you want to check e.g. the setName method of a class, insert a line </p>
<dl class="user"><dt><b></b></dt><dd><a class="el" href="group__ClassTest.html#ga3f863350d1b8ff0e07f55d6668b868ff">CHECK(setName)</a># </dd></dl>
<dl class="user"><dt><b></b></dt><dd>in your test program. If the test program is called in verbose mode, this leads to the name of the subtest being printed on execution. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This macro also opens a <code>try</code> block to catch any unexpected exceptions thrown in the course of a subtest. To catch <b> wanted </b> exceptions (i.e. to check for exceptions that are the expected result of some command) use the <a class="el" href="group__ClassTest.html#ga29e985393ac63f000023bf684f4d03fc">TEST_EXCEPTION </a> macro. The <code>try</code> block opened by CHECK is closed in <a class="el" href="group__ClassTest.html#ga62c939ffea0f34a0211837f4dbecee0a">RESULT </a> , so these two macros have to be balanced. </dd></dl>

</div>
</div>
<a class="anchor" id="gac3823150353426a957bb759359c3ceee"></a><!-- doxytag: member="classTest.h::COMPARE_OUTPUT" ref="gac3823150353426a957bb759359c3ceee" args="(text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COMPARE_OUTPUT</td>
          <td>(</td>
          <td class="paramtype">text&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="namespaceBALL.html#a3285ecab87c03c25e43e326d3cf3e79e">Log</a>.remove(TEST_strstr);\
    <a class="code" href="namespaceBALL.html#a3285ecab87c03c25e43e326d3cf3e79e">Log</a>.insert(std::cout, LogStream::INFORMATION_LEVEL, LogStream::ERROR_LEVEL - 1);\
    <a class="code" href="namespaceBALL.html#a3285ecab87c03c25e43e326d3cf3e79e">Log</a>.insert(std::cerr, LogStream::ERROR_LEVEL);\
    TEST::this_test = (::strncmp(TEST_strstr.str(), text, TEST_strstr.str()!=0?strlen(TEST_strstr.str()):0) == 0);\
    TEST::test = TEST::test &amp;&amp; TEST::this_test;\
    \
    <span class="keywordflow">if</span> ((TEST::verbose &gt; 1) || (!TEST::this_test &amp;&amp; (TEST::verbose &gt; 0)))\
    {\
      <span class="comment">/* reserve space for the null-terminated content of the strstrem */</span>\
      <span class="keywordtype">char</span>* TEST_strstr_contents = <span class="keyword">new</span> <span class="keywordtype">char</span>[TEST_strstr.str()!=0?strlen(TEST_strstr.str()):0 + 1];\
      ::strncpy(TEST_strstr_contents, TEST_strstr.str(), TEST_strstr.str()!=0?strlen(TEST_strstr.str()):0);\
      TEST_strstr_contents[TEST_strstr.str()!=0?strlen(TEST_strstr.str()):0] = <span class="charliteral">&apos;\0&apos;</span>;\
      \
      <span class="keywordflow">if</span> (!TEST::newline)\
      {\
        TEST::newline = <span class="keyword">true</span>;\
        std::cout &lt;&lt; std::endl;\
      }\
      std::cout &lt;&lt; <span class="stringliteral">&quot;    (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="stringliteral">&quot; COMPARE_OUTPUT(&quot;</span> &lt;&lt; #text &lt;&lt; <span class="stringliteral">&quot;): got &apos;&quot;</span> &lt;&lt; (TEST_strstr_contents) &lt;&lt; <span class="stringliteral">&quot;&apos;, expected &apos;&quot;</span> &lt;&lt; (text) &lt;&lt; <span class="stringliteral">&quot;&apos;) &quot;</span>;\
      <span class="keywordflow">if</span> (TEST::this_test)\
        std::cout &lt;&lt; <span class="stringliteral">&quot; + &quot;</span> &lt;&lt; std::endl;\
      <span class="keywordflow">else</span> \
        std::cout &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; std::endl;\
      <span class="keyword">delete</span> [] TEST_strstr_contents;\
    }\
  }
</pre></div><p>Compare output made to the global logging facility. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>CAPTURE_OUTPUT </dd></dl>

</div>
</div>
<a class="anchor" id="gaefcd1ca1799d2395f7bbe3c50bcc8ff8"></a><!-- doxytag: member="classTest.h::END_TEST" ref="gaefcd1ca1799d2395f7bbe3c50bcc8ff8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define END_TEST</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Termination of test program. This macro implements the correct termination of the test program and should therefore be the last macro to call. It determines the exit code based on all previously run subtests and prints out the message "PASSED" or "FAILED". This macro also closes the global <code>try</code> block opened by <a class="el" href="group__ClassTest.html#ga7a40a89e644997d4c2ff42b1068658e2">START_TEST </a> and contains the related <code>catch</code> clauses. If an exception is caught here, the test program fails. </p>

</div>
</div>
<a class="anchor" id="gadf364cea1469a3b7ebfde9e01332265f"></a><!-- doxytag: member="classTest.h::NEW_TMP_FILE" ref="gadf364cea1469a3b7ebfde9e01332265f" args="(filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NEW_TMP_FILE</td>
          <td>(</td>
          <td class="paramtype">filename&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="classBALL_1_1File.html#ac512171e21f7b80063fe2ea3cb01ddd1">::BALL::File::createTemporaryFilename</a>(filename);\
          TEST::tmp_file_list.push_back(filename);\
          <span class="keywordflow">if</span> (TEST::verbose &gt; 1)\
          {\
            <span class="keywordflow">if</span> (!TEST::newline) \
            {\
              TEST::newline = <span class="keyword">true</span>;\
              std::cout &lt;&lt; std::endl;\
            }\
            std::cout &lt;&lt; <span class="stringliteral">&quot;  creating new temporary file &apos;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&apos; (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;\
          }\
</pre></div><p>Create a temporary filename. This macro assigns a new temporary filename to the string variable given as its argument. The filename is created using <a class="el" href="classBALL_1_1File.html#ac512171e21f7b80063fe2ea3cb01ddd1">File::createTemporaryFilename </a> . All temporary files are deleted if <a class="el" href="group__ClassTest.html#gaefcd1ca1799d2395f7bbe3c50bcc8ff8">END_TEST </a> is called. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>String will contain the filename on completion of the macro </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga90ef7ac5849c83a72a0f1425f28939f2"></a><!-- doxytag: member="classTest.h::PRECISION" ref="ga90ef7ac5849c83a72a0f1425f28939f2" args="(a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PRECISION</td>
          <td>(</td>
          <td class="paramtype">a&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;TEST::precision = (a);</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define the precision for floating point comparisons. The macro <a class="el" href="group__ClassTest.html#ga206d7219a2ba5116b25b61457a629e62">TEST_REAL_EQUAL </a> checks whether the floating point number returned by the subtest is close to the expected result by comparing the absolute value of the difference of the two values to <b>PRECISION</b>. </p>
<dl class="user"><dt><b></b></dt><dd>The default value is $10^{-6}$. It is possible to redefine precision in the test program by calling this macro with the new value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga62c939ffea0f34a0211837f4dbecee0a"></a><!-- doxytag: member="classTest.h::RESULT" ref="ga62c939ffea0f34a0211837f4dbecee0a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RESULT</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check subtest result. Each elementary test macro updates an internal variable (<b>TEST</b>, defined by <a class="el" href="group__ClassTest.html#ga7a40a89e644997d4c2ff42b1068658e2">START_TEST </a> ) that holds the state of the current subtest. </p>
<dl class="user"><dt><b></b></dt><dd><b>RESULT</b> prints whether the subtest has failed or passed in verbose mode and updates the internal variables <b>TEST::all_tests</b> that describes the state of the whole class test. <b>TEST::all_tests</b> is initialized to be <b>true</b>. If any elementary test fails, <b>TEST::test</b> becomes <b>false</b>. At the time of the next call to <b>RESULT</b>, <b>TEST::all_tests</b> will be set to false, if <b>TEST::test</b> is false. One failed elementary test leads therefore to a failed subtest, which leads to a failed class test. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This macro closes the <code>try</code> block opened by CHECK, so CHECK and RESULT have to be balanced, or some ugly compile-time errors may occur. RESULT first tries to catch all <code><a class="el" href="namespaceBALL.html">BALL</a></code> exceptions (i.e. exceptions derived from GeneralException). If this fails, it tries to catch any exception. After the exception is thrown, the execution will continue with the next subtest, the current subtest will be marked as failed (as is the whole test program). </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a40a89e644997d4c2ff42b1068658e2"></a><!-- doxytag: member="classTest.h::START_TEST" ref="ga7a40a89e644997d4c2ff42b1068658e2" args="(class_name, version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define START_TEST</td>
          <td>(</td>
          <td class="paramtype">class_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">version&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create the test header for a certain class. This macro defines the start of the test program for a given classname. The classname is printed together with some information when calling the test program with any arguments (except for #-v# or #-V#). </p>
<dl class="user"><dt><b></b></dt><dd>This macro should be the first to call in a test program. It introduces a global <code>try</code> block to catch any unwanted exceptions. If any of these exceptions occurs, all tests failed. Exceptions defined by <a class="el" href="namespaceBALL.html">BALL</a> (i.e. exception classes derived from <a class="el" href="classBALL_1_1Exception_1_1GeneralException.html">GeneralException </a> ) provide some additional information that is evaluated by the <a class="el" href="group__ClassTest.html#gaefcd1ca1799d2395f7bbe3c50bcc8ff8">END_TEST </a> macro. The END_TEST macro also closes the <code>try</code> block. This <code>try</code> block should never catch an exception! All exceptions that are thrown due to some malfunction in one of the member functions should be caught by the <code>try</code> block created by <a class="el" href="group__ClassTest.html#ga3f863350d1b8ff0e07f55d6668b868ff">CHECK </a> and <a class="el" href="group__ClassTest.html#ga62c939ffea0f34a0211837f4dbecee0a">RESULT </a> . </dd></dl>

</div>
</div>
<a class="anchor" id="ga2491d6c44db439274567cea0a3e6f712"></a><!-- doxytag: member="classTest.h::STATUS" ref="ga2491d6c44db439274567cea0a3e6f712" args="(message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STATUS</td>
          <td>(</td>
          <td class="paramtype">message&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (TEST::verbose &gt; 1)\
          {\
            <span class="keywordflow">if</span> (!TEST::newline) \
            {\
              TEST::newline = <span class="keyword">true</span>;\
              std::cout &lt;&lt; std::endl;\
            }\
            std::cout &lt;&lt; <span class="stringliteral">&quot;  status (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; message &lt;&lt; std::endl;\
          }\
</pre></div><p>Print a status message. If tests require longer preparations, <code>STATUS</code> may be used to print some intermediated progress messages. <code>STATUS</code> uses <code>cout</code> to print these messages (in verbose mode only). The given stream expression <code>message</code> is prefixed by the string <code>status:</code> and terminated with a newline. All valid operations on a stream may be performed in <code>message</code>. </p>
<dl class="user"><dt><b></b></dt><dd><b>Example:</b> </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">
		STATUS("just calculated x = " &lt;&lt; setprecision(10) &lt;&lt; x)
		</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="ga28c3e33e75987220375e36d1480e26ec"></a><!-- doxytag: member="classTest.h::TEST_EQUAL" ref="ga28c3e33e75987220375e36d1480e26ec" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TEST_EQUAL</td>
          <td>(</td>
          <td class="paramtype">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{\
    TEST::this_test = ((a) == (b));\
    TEST::test = TEST::test &amp;&amp; TEST::this_test;\
    <span class="keywordflow">if</span> ((TEST::verbose &gt; 1) || (!TEST::this_test &amp;&amp; (TEST::verbose &gt; 0)))\
    {\
      <span class="keywordflow">if</span> (!TEST::newline)\
      {\
        TEST::newline = <span class="keyword">true</span>;\
        std::cout &lt;&lt; std::endl;\
      }\
      std::cout &lt;&lt; <span class="stringliteral">&quot;    (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="stringliteral">&quot; TEST_EQUAL(&quot;</span> &lt;&lt; #a &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; #b &lt;&lt; <span class="stringliteral">&quot;): got &quot;</span> &lt;&lt; (a) &lt;&lt; <span class="stringliteral">&quot;, expected &quot;</span> &lt;&lt; (b) &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>;\
      <span class="keywordflow">if</span> (TEST::this_test)\
        std::cout &lt;&lt; <span class="stringliteral">&quot; + &quot;</span> &lt;&lt; std::endl;\
      <span class="keywordflow">else</span> \
        std::cout &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; std::endl;\
    }\
  }\
</pre></div><p>Generic equality macro. This macro uses the operator == to check its two arguments for equality. Besides handling some internal stuff, it basically evaluates #((a) == (b))#. </p>
<dl class="user"><dt><b></b></dt><dd>Remember that operator == has to be defined somehow for the two argument types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>value/object to test </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>expected value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga29e985393ac63f000023bf684f4d03fc"></a><!-- doxytag: member="classTest.h::TEST_EXCEPTION" ref="ga29e985393ac63f000023bf684f4d03fc" args="(exception_type, command)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TEST_EXCEPTION</td>
          <td>(</td>
          <td class="paramtype">exception_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">command&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exception test macro. This macro checks if a given type of exception occured while executing the given command. Example: </p>
<dl class="user"><dt><b></b></dt><dd><a class="el" href="group__ClassTest.html#ga29e985393ac63f000023bf684f4d03fc">TEST_EXCEPTION</a>(Exception::IndexOverflow, vector3[-1])# </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If no or a wrong exception occured, false is returned, otherwise true. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>exception_type</em>&nbsp;</td><td>the exception-class </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>command</em>&nbsp;</td><td>any general C++ or BALL-specific command </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga219dba5ec44005d226e707f1ab8edd2e"></a><!-- doxytag: member="classTest.h::TEST_FILE" ref="ga219dba5ec44005d226e707f1ab8edd2e" args="(filename, templatename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TEST_FILE</td>
          <td>(</td>
          <td class="paramtype">filename, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templatename&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>File comparison macro. This macro is used to test file operations. It compares the file with name <code>filename</code> against a template file <code>templatename</code>. Corresponding lines of the two files have to be identical. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__ClassTest.html#ga6dd175ba0b13a37ca85a7493dca42f05">TEST_FILE_REGEXP</a> for more sophisticated comparisons </dd></dl>

</div>
</div>
<a class="anchor" id="ga6dd175ba0b13a37ca85a7493dca42f05"></a><!-- doxytag: member="classTest.h::TEST_FILE_REGEXP" ref="ga6dd175ba0b13a37ca85a7493dca42f05" args="(filename, templatename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TEST_FILE_REGEXP</td>
          <td>(</td>
          <td class="paramtype">filename, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templatename&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Regular expression file comparison macro. This macro is used to test file operations. It compares the file with name <code>filename</code> against a template file <code>templatename</code>. Each line of the template file starting with <code>``/''</code> is considered to contain a regular expression, which has to match the corresponding line in the input file. All other lines of the input and the template file have to be identical. </p>

</div>
</div>
<a class="anchor" id="gaf2f6f2b204d65f32c50a4411dc590fa3"></a><!-- doxytag: member="classTest.h::TEST_NOT_EQUAL" ref="gaf2f6f2b204d65f32c50a4411dc590fa3" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TEST_NOT_EQUAL</td>
          <td>(</td>
          <td class="paramtype">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{\
    TEST::this_test = !((a) == (b));\
    TEST::test = TEST::test &amp;&amp; TEST::this_test;\
    <span class="keywordflow">if</span> ((TEST::verbose &gt; 1) || (!TEST::this_test &amp;&amp; (TEST::verbose &gt; 0)))\
    {\
      <span class="keywordflow">if</span> (!TEST::newline)\
      {\
        TEST::newline = <span class="keyword">true</span>;\
        std::cout &lt;&lt; std::endl;\
      }\
      std::cout &lt;&lt; <span class="stringliteral">&quot;    (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="stringliteral">&quot; TEST_NOT_EQUAL(&quot;</span> &lt;&lt; #a &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; #b &lt;&lt; <span class="stringliteral">&quot;): got &quot;</span> &lt;&lt; (a) &lt;&lt; <span class="stringliteral">&quot;, forbidden is &quot;</span> &lt;&lt; (b) &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>;\
      <span class="keywordflow">if</span> (TEST::this_test)\
        std::cout &lt;&lt; <span class="stringliteral">&quot; + &quot;</span> &lt;&lt; std::endl;\
      <span class="keywordflow">else</span> \
        std::cout &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; std::endl;\
    }\
  }\
</pre></div><p>Generic inequality macro. This macro checks for inequality as <a class="el" href="group__ClassTest.html#ga28c3e33e75987220375e36d1480e26ec">TEST_EQUAL </a> tests for equality. The only difference between the two macros is that<b> TEST_NOT_EQUAL</b> evaluates #!((a) == (b))#. </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>value/object to test </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>forbidden value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6fff47799e22d307f16eabdfbb0291e2"></a><!-- doxytag: member="classTest.h::TEST_PRECONDITION_EXCEPTION" ref="ga6fff47799e22d307f16eabdfbb0291e2" args="(command)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TEST_PRECONDITION_EXCEPTION</td>
          <td>(</td>
          <td class="paramtype">command&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (TEST::verbose &gt; 1)\
  {\
    std::cout &lt;&lt; <span class="stringliteral">&quot;  TEST_EXCEPTION_PRECONDITION(&quot;</span> #command <span class="stringliteral">&quot;) : (DEBUG mode disabled!)&quot;</span> &lt;&lt; std::endl;\
  }\
</pre></div><p>Precondition exception test macro. This macro checks if a the command specified correctly throws an exception of type Precondition because one of its preconditions is violated. If <a class="el" href="namespaceBALL.html">BALL</a> is not compile din DEBUG mode, this macro won't do anything, as the BALL_EXCEPTION_PRECONDITION macro is expanded to nothing in that case. </p>

</div>
</div>
<a class="anchor" id="ga206d7219a2ba5116b25b61457a629e62"></a><!-- doxytag: member="classTest.h::TEST_REAL_EQUAL" ref="ga206d7219a2ba5116b25b61457a629e62" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TEST_REAL_EQUAL</td>
          <td>(</td>
          <td class="paramtype">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">TEST::this_test = <a class="code" href="macros_8h.html#ac72bb57fda7abba0c8edfb2538ae5018">BALL_REAL_EQUAL</a>((a), (b), TEST::precision); \
  TEST::test = TEST::test &amp;&amp; TEST::this_test;\
  <span class="keywordflow">if</span> ((TEST::verbose &gt; 1) || (!TEST::this_test &amp;&amp; (TEST::verbose &gt; 0)))\
  {\
    <span class="keywordflow">if</span> (!TEST::newline)\
    {\
      TEST::newline = <span class="keyword">true</span>;\
      std::cout &lt;&lt; std::endl;\
    }\
    std::cout &lt;&lt; <span class="stringliteral">&quot;    (line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="stringliteral">&quot; TEST_REAL_EQUAL(&quot;</span>&lt;&lt; #a &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; #b &lt;&lt; <span class="stringliteral">&quot;): got &quot;</span> &lt;&lt; (a) &lt;&lt; <span class="stringliteral">&quot;, expected &quot;</span> &lt;&lt; (b) &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>;\
    <span class="keywordflow">if</span> (TEST::this_test)\
      std::cout &lt;&lt; <span class="stringliteral">&quot; + &quot;</span> &lt;&lt; std::endl;\
    <span class="keywordflow">else</span> \
      std::cout &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; std::endl;\
  }\
</pre></div><p>Floating point equality macro. Checks whether the absolute value of the difference of the two floating point values <b>a</b> and <b>b</b> is less or equal to the value defined by <a class="el" href="group__ClassTest.html#ga90ef7ac5849c83a72a0f1425f28939f2">PRECISION </a> . </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>floating point value to test </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>expected value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
</div>
</body>
</html>
